{
  "version": 3,
  "sources": ["../../@tsparticles/shape-emoji/browser/Utils.js", "../../@tsparticles/shape-emoji/browser/EmojiDrawer.js"],
  "sourcesContent": ["export function drawEmoji(data) {\n    const { context, particle, radius, opacity } = data, emojiData = particle.emojiData, double = 2, diameter = radius * double, previousAlpha = context.globalAlpha;\n    if (!emojiData) {\n        return;\n    }\n    context.globalAlpha = opacity;\n    context.drawImage(emojiData, -radius, -radius, diameter, diameter);\n    context.globalAlpha = previousAlpha;\n}\n", "import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nimport { drawEmoji } from \"./Utils.js\";\nimport { validTypes } from \"./Constants.js\";\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"';\nexport class EmojiDrawer {\n    constructor() {\n        this._emojiShapeDict = new Map();\n    }\n    destroy() {\n        for (const [key, emojiData] of this._emojiShapeDict) {\n            if (emojiData instanceof ImageBitmap) {\n                emojiData?.close();\n                this._emojiShapeDict.delete(key);\n            }\n        }\n    }\n    draw(data) {\n        drawEmoji(data);\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!validTypes.find((t) => isInArray(t, options.particles.shape.type))) {\n            return;\n        }\n        const promises = [loadFont(defaultFont)], shapeOptions = validTypes\n            .map((t) => options.particles.shape.options[t])\n            .find((t) => !!t);\n        if (shapeOptions) {\n            executeOnSingleOrMultiple(shapeOptions, (shape) => {\n                if (shape.font) {\n                    promises.push(loadFont(shape.font));\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    particleDestroy(particle) {\n        delete particle.emojiData;\n    }\n    particleInit(container, particle) {\n        const double = 2, shapeData = particle.shapeData;\n        if (!shapeData?.value) {\n            return;\n        }\n        const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData), font = shapeData.font ?? defaultFont;\n        if (!emoji) {\n            return;\n        }\n        const key = `${emoji}_${font}`, existingData = this._emojiShapeDict.get(key);\n        if (existingData) {\n            particle.emojiData = existingData;\n            return;\n        }\n        const canvasSize = getRangeMax(particle.size.value) * double;\n        let emojiData;\n        const maxSize = getRangeMax(particle.size.value);\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            const canvas = new OffscreenCanvas(canvasSize, canvasSize), context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, maxSize, maxSize);\n            emojiData = canvas.transferToImageBitmap();\n        }\n        else {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = canvasSize;\n            canvas.height = canvasSize;\n            const context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, maxSize, maxSize);\n            emojiData = canvas;\n        }\n        this._emojiShapeDict.set(key, emojiData);\n        particle.emojiData = emojiData;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
